{"version":3,"file":"safe-form.umd.js","sources":["../src/FormActionError.ts","../src/helpers/parseZodError.ts","../src/helpers/serializer.ts","../src/helpers/parseValueFromInput.ts","../src/useForm.ts","../src/createFormAction.ts"],"sourcesContent":["export class FormActionError extends Error {}\n","import { z } from 'zod'\nimport { FormFieldErrors, FormInput } from '..'\n\nexport const parseZodError = <Input extends FormInput>(\n  error: z.ZodError\n): FormFieldErrors<Input> => {\n  return error.flatten().fieldErrors as FormFieldErrors<Input>\n}\n","import { FormInput } from '../types'\nconst SCALARS_FIELD = '__safe-form-scalars'\n\nexport const createFormData = <Input extends FormInput>(values: Input) => {\n  const formData = new FormData()\n  let scalars: any = {}\n\n  for (const [name, value] of Object.entries(values)) {\n    // Handle files\n    if (value instanceof File) {\n      formData.append(name, value)\n      continue\n    }\n\n    // Handle scalars\n    scalars[name] = value\n  }\n\n  formData.append(SCALARS_FIELD, JSON.stringify(scalars))\n\n  return formData\n}\n\nexport const parseFormData = (formData: FormData): Record<string, unknown> => {\n  const input: Record<string, unknown> = {}\n\n  for (const [name, value] of Array.from(formData.entries())) {\n    // Handle scalars\n    if (name === SCALARS_FIELD) {\n      const scalars = JSON.parse(value as string)\n      for (const [name, value] of Object.entries(scalars)) {\n        input[name] = value\n      }\n      continue\n    }\n\n    // Handle files\n    input[name] = value\n  }\n\n  return input\n}\n","export const parseValueFromInput = (\n  input: HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement\n) => {\n  if (\n    input instanceof HTMLSelectElement ||\n    input instanceof HTMLTextAreaElement\n  ) {\n    return input.value\n  }\n\n  if (input.type === 'checkbox') {\n    return input.checked\n  }\n\n  if (input.type === 'number') {\n    const number = parseFloat(input.value || '0')\n    return isNaN(number) ? null : number\n  }\n\n  if (input.type === 'file') {\n    return input.files?.[0] ?? null\n  }\n\n  if (input.type === 'radio') {\n    return input.checked ? input.value : null\n  }\n\n  if (input.type === 'date') {\n    return input.valueAsDate?.toISOString() ?? null\n  }\n\n  return input.value\n}\n","'use client'\n\nimport { createFormData } from '@/helpers/serializer'\nimport {\n  FormHTMLAttributes,\n  InputHTMLAttributes,\n  RefAttributes,\n  RefObject,\n  SyntheticEvent,\n  createRef,\n  useCallback,\n  useEffect,\n  useRef,\n  useState,\n  useTransition\n} from 'react'\nimport { flushSync, useFormState } from 'react-dom'\nimport { z } from 'zod'\nimport { parseValueFromInput } from './helpers/parseValueFromInput'\nimport { parseZodError } from './helpers/parseZodError'\nimport { FormAction, FormFieldErrors, FormInput, FormState } from './types'\n\ntype BindableField = HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement\n\ntype UseFormParams<Input extends FormInput, FormResponse> = {\n  action: FormAction<Input, FormResponse>\n  schema?: z.Schema<Input>\n  initialState?: FormState<Input, FormResponse> | null\n  initialValues?: Partial<Input>\n  validateOnBlur?: boolean\n  validateOnChange?: boolean\n  onSubmit?: (input: Input) => boolean\n  onSuccess?: (response: FormResponse) => void\n  onError?: (\n    error: string | null,\n    fieldErrors: FormFieldErrors<Input> | null\n  ) => void\n}\n\ntype UseFormReturn<Input extends FormInput, FormResponse> = {\n  error: string | null\n  response: FormResponse | null\n  fieldErrors: FormFieldErrors<Input>\n  isPending: boolean\n  connect: () => FormHTMLAttributes<HTMLFormElement>\n  getAll: () => Input\n  validateAll: () => boolean\n  getField: <Field extends keyof Input>(name: Field) => Input[Field]\n  setField: <Field extends keyof Input>(\n    name: Field,\n    value: Input[Field]\n  ) => void\n  validateField: <Field extends keyof Input>(name: Field) => boolean\n  bindField: (name: keyof Input) => any // TODO: Fix this type\n}\n\nexport const useForm = <Input extends FormInput, FormResponse>({\n  action,\n  schema,\n  initialState,\n  initialValues,\n  validateOnBlur,\n  validateOnChange,\n  onSubmit,\n  onSuccess,\n  onError\n}: UseFormParams<Input, FormResponse>): UseFormReturn<Input, FormResponse> => {\n  const inputRef = useRef<\n    { [field in keyof Input]?: RefObject<BindableField> } | null\n  >(null)\n  const [isPending, startTransition] = useTransition()\n  const [formState, formAction] = useFormState(action, initialState ?? null)\n  const [fieldErrors, setFieldErrors] = useState<FormFieldErrors<Input>>({})\n  const [values, setValues] = useState<Input>(\n    (initialValues as Input) ?? ({} as Input)\n  )\n\n  const getAll = useCallback(() => {\n    // If there are no bound fields, just return values\n    if (!inputRef.current) {\n      return values\n    }\n\n    // Otherwise, get the values from the bound fields\n    let _values: Record<string, unknown> = values\n    for (const [field, ref] of Object.entries(inputRef.current)) {\n      if (!ref?.current) {\n        continue\n      }\n\n      _values[field] = parseValueFromInput(ref.current)\n    }\n\n    setValues({\n      ...values,\n      ...(_values as Input)\n    })\n\n    return _values as Input\n  }, [inputRef, values])\n\n  const validateAll = useCallback(() => {\n    // Get all the values before validating\n    const input = getAll()\n\n    // If there is no schema, skip validation\n    if (!schema) return true\n\n    // Validate all fields\n    const validation = schema.safeParse(input)\n\n    if (!validation.success) {\n      setFieldErrors(parseZodError(validation.error))\n      return false\n    }\n\n    // Reset field errors if validation is successful\n    setFieldErrors({})\n    return true\n  }, [setFieldErrors, schema, inputRef, getAll])\n\n  const getField = useCallback(\n    <Field extends keyof Input>(name: Field) => {\n      return values[name]\n    },\n    [values]\n  )\n\n  const setField = useCallback(\n    <Field extends keyof Input>(name: keyof Input, value: Input[Field]) => {\n      setValues((values) => ({\n        ...values,\n        [name]: value\n      }))\n    },\n    [inputRef, setValues]\n  )\n\n  const validateField = useCallback(\n    <Field extends keyof Input>(name: Field) => {\n      // If there is no schema, skip validation\n      if (!schema) return true\n\n      // If it's a bound field, get the value from the ref\n      let value = values[name]\n      if (inputRef.current?.[name]?.current) {\n        value = parseValueFromInput(\n          inputRef.current[name]!.current!\n        ) as Input[Field]\n      }\n\n      const validation = schema.safeParse({\n        [name]: value\n      })\n\n      // Validate a single field\n      if (!validation.success) {\n        const errors = parseZodError<Input>(validation.error)[name]\n\n        if (errors) {\n          setFieldErrors((fieldErrors) => ({\n            ...fieldErrors,\n            [name]: errors\n          }))\n          return false\n        }\n      }\n\n      // Reset this field's error if validation is successful\n      setFieldErrors((fieldErrors) => ({\n        ...fieldErrors,\n        [name]: undefined\n      }))\n      return true\n    },\n    [setFieldErrors, schema, inputRef, getAll]\n  )\n\n  const connect = useCallback(() => {\n    return {\n      onSubmit: (event: SyntheticEvent<HTMLFormElement>) => {\n        event.preventDefault()\n\n        // Reset field errors\n        setFieldErrors({})\n\n        // If there is an onSubmit callback, call it\n        if (onSubmit && !onSubmit(getAll())) {\n          return\n        }\n\n        // Validate all fields before submitting\n        let validation = false\n        flushSync(() => {\n          validation = validateAll()\n        })\n        if (!validation) {\n          return\n        }\n\n        // Create a FormData object from the values\n        const formData = createFormData(values)\n\n        // Call the server action\n        startTransition(async () => {\n          await formAction(formData)\n        })\n      },\n      action: formAction\n    } satisfies Pick<FormHTMLAttributes<HTMLFormElement>, 'onSubmit' | 'action'>\n  }, [\n    values,\n    validateAll,\n    setFieldErrors,\n    formAction,\n    startTransition,\n    formAction\n  ])\n\n  const bindField = useCallback(\n    (name: keyof Input) => {\n      if (inputRef.current === null) {\n        inputRef.current = {}\n      }\n\n      inputRef.current[name] = createRef()\n\n      return {\n        ref: inputRef.current[name],\n        name: name.toString(),\n        onBlur: validateOnBlur ? () => validateField(name) : undefined,\n        onChange: validateOnChange ? () => validateField(name) : undefined\n      } satisfies InputHTMLAttributes<HTMLInputElement> &\n        RefAttributes<BindableField>\n    },\n    [inputRef, validateField, validateOnBlur, validateOnChange]\n  )\n\n  useEffect(() => {\n    if (formState?.error || formState?.fieldErrors) {\n      onError?.(formState?.error ?? null, formState?.fieldErrors ?? null)\n    }\n    if (formState?.response) {\n      onSuccess?.(formState.response)\n    }\n  }, [formState])\n\n  return {\n    error: formState?.error ?? null,\n    response: formState?.response ?? null,\n    fieldErrors:\n      formState?.fieldErrors ?? fieldErrors ?? ({} as FormFieldErrors<Input>),\n    isPending,\n    getAll,\n    validateAll,\n    getField,\n    setField,\n    validateField,\n    connect,\n    bindField\n  }\n}\n","import { z } from 'zod'\nimport { FormActionError } from './FormActionError'\nimport { parseZodError } from './helpers/parseZodError'\nimport { parseFormData } from './helpers/serializer'\nimport { FormAction, FormInput, FormState } from './types'\n\nexport const createFormAction = <Input extends FormInput, FormResponse>(\n  schema: z.Schema<Input>,\n  handler: (\n    validatedInput: Input,\n    initialState?: FormState<Input, FormResponse> | null\n  ) => Promise<FormResponse>\n): FormAction<Input, FormResponse> => {\n  return async (initialState, formData) => {\n    const input = parseFormData(formData)\n    const validatedInput = schema.safeParse(input)\n\n    if (!validatedInput.success) {\n      return {\n        fieldErrors: parseZodError<Input>(validatedInput.error)\n      }\n    }\n\n    try {\n      const output = await handler(validatedInput.data, initialState)\n\n      return {\n        response: output\n      }\n    } catch (error: unknown) {\n      if (error instanceof FormActionError) {\n        return { error: error.message }\n      }\n\n      throw error\n    }\n  }\n}\n\nexport { useForm } from './useForm'\n"],"names":["FormActionError","parseZodError","error","SCALARS_FIELD","createFormData","values","formData","scalars","name","value","parseFormData","input","parseValueFromInput","number","_a","_b","useForm","action","schema","initialState","initialValues","validateOnBlur","validateOnChange","onSubmit","onSuccess","onError","inputRef","useRef","isPending","startTransition","useTransition","formState","formAction","useFormState","fieldErrors","setFieldErrors","useState","setValues","getAll","useCallback","_values","field","ref","validateAll","validation","getField","setField","validateField","errors","connect","event","flushSync","bindField","createRef","useEffect","createFormAction","handler","validatedInput"],"mappings":"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"}