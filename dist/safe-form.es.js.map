{"version":3,"file":"safe-form.es.js","sources":["../src/FormActionError.ts","../src/helpers/parseZodError.ts","../src/helpers/serializer.ts","../src/helpers/parseValueFromInput.ts","../src/useForm.ts","../src/createFormAction.ts"],"sourcesContent":["export class FormActionError extends Error {}\n","import { z } from 'zod'\nimport { FormFieldErrors, FormInput } from '..'\n\nexport const parseZodError = <Input extends FormInput>(\n  error: z.ZodError\n): FormFieldErrors<Input> => {\n  return error.flatten().fieldErrors as FormFieldErrors<Input>\n}\n","import { FormInput } from '../types'\nconst SCALARS_FIELD = '__safe-form-scalars'\n\nexport const createFormData = <Input extends FormInput>(values: Input) => {\n  const formData = new FormData()\n  let scalars: any = {}\n\n  for (const [name, value] of Object.entries(values)) {\n    // Handle files\n    if (value instanceof File) {\n      formData.append(name, value)\n      continue\n    }\n\n    // Handle scalars\n    scalars[name] = value\n  }\n\n  formData.append(SCALARS_FIELD, JSON.stringify(scalars))\n\n  return formData\n}\n\nexport const parseFormData = (formData: FormData): Record<string, unknown> => {\n  const input: Record<string, unknown> = {}\n\n  for (const [name, value] of Array.from(formData.entries())) {\n    // Handle scalars\n    if (name === SCALARS_FIELD) {\n      const scalars = JSON.parse(value as string)\n      for (const [name, value] of Object.entries(scalars)) {\n        input[name] = value\n      }\n      continue\n    }\n\n    // Handle files\n    input[name] = value\n  }\n\n  return input\n}\n","export const parseValueFromInput = (\n  input: HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement\n) => {\n  if (\n    input instanceof HTMLSelectElement ||\n    input instanceof HTMLTextAreaElement\n  ) {\n    return input.value\n  }\n\n  if (input.type === 'checkbox') {\n    return input.checked\n  }\n\n  if (input.type === 'number') {\n    const number = parseFloat(input.value || '0')\n    return isNaN(number) ? null : number\n  }\n\n  if (input.type === 'file') {\n    return input.files?.[0] ?? null\n  }\n\n  if (input.type === 'radio') {\n    return input.checked ? input.value : null\n  }\n\n  if (input.type === 'date') {\n    return input.valueAsDate?.toISOString() ?? null\n  }\n\n  return input.value\n}\n","'use client'\n\nimport { createFormData } from '@/helpers/serializer'\nimport {\n  FormHTMLAttributes,\n  InputHTMLAttributes,\n  RefAttributes,\n  RefObject,\n  SyntheticEvent,\n  createRef,\n  useCallback,\n  useEffect,\n  useRef,\n  useState,\n  useTransition\n} from 'react'\nimport { flushSync, useFormState } from 'react-dom'\nimport { z } from 'zod'\nimport { parseValueFromInput } from './helpers/parseValueFromInput'\nimport { parseZodError } from './helpers/parseZodError'\nimport { FormAction, FormFieldErrors, FormInput, FormState } from './types'\n\ntype BindableField = HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement\n\ntype UseFormParams<Input extends FormInput, FormResponse> = {\n  action: FormAction<Input, FormResponse>\n  schema?: z.Schema<Input>\n  initialState?: FormState<Input, FormResponse> | null\n  initialValues?: Partial<Input>\n  validateOnBlur?: boolean\n  validateOnChange?: boolean\n  onSubmit?: (input: Input) => boolean\n  onSuccess?: (response: FormResponse) => void\n  onError?: (\n    error: string | null,\n    fieldErrors: FormFieldErrors<Input> | null\n  ) => void\n}\n\ntype UseFormReturn<Input extends FormInput, FormResponse> = {\n  error: string | null\n  response: FormResponse | null\n  fieldErrors: FormFieldErrors<Input>\n  isPending: boolean\n  connect: () => FormHTMLAttributes<HTMLFormElement>\n  getAll: () => Input\n  validateAll: () => boolean\n  getField: <Field extends keyof Input>(name: Field) => Input[Field]\n  setField: <Field extends keyof Input>(\n    name: Field,\n    value: Input[Field]\n  ) => void\n  validateField: <Field extends keyof Input>(name: Field) => boolean\n  bindField: (name: keyof Input) => any // TODO: Fix this type\n}\n\nexport const useForm = <Input extends FormInput, FormResponse>({\n  action,\n  schema,\n  initialState,\n  initialValues,\n  validateOnBlur,\n  validateOnChange,\n  onSubmit,\n  onSuccess,\n  onError\n}: UseFormParams<Input, FormResponse>): UseFormReturn<Input, FormResponse> => {\n  const inputRef = useRef<\n    { [field in keyof Input]?: RefObject<BindableField> } | null\n  >(null)\n  const [isPending, startTransition] = useTransition()\n  const [formState, formAction] = useFormState(action, initialState ?? null)\n  const [fieldErrors, setFieldErrors] = useState<FormFieldErrors<Input>>({})\n  const [values, setValues] = useState<Input>(\n    (initialValues as Input) ?? ({} as Input)\n  )\n\n  const getAll = useCallback(() => {\n    // If there are no bound fields, just return values\n    if (!inputRef.current) {\n      return values\n    }\n\n    // Otherwise, get the values from the bound fields\n    let _values: Record<string, unknown> = values\n    for (const [field, ref] of Object.entries(inputRef.current)) {\n      if (!ref?.current) {\n        continue\n      }\n\n      _values[field] = parseValueFromInput(ref.current)\n    }\n\n    setValues({\n      ...values,\n      ...(_values as Input)\n    })\n\n    return _values as Input\n  }, [inputRef, values])\n\n  const validateAll = useCallback(() => {\n    // Get all the values before validating\n    const input = getAll()\n\n    // If there is no schema, skip validation\n    if (!schema) return true\n\n    // Validate all fields\n    const validation = schema.safeParse(input)\n\n    if (!validation.success) {\n      setFieldErrors(parseZodError(validation.error))\n      return false\n    }\n\n    // Reset field errors if validation is successful\n    setFieldErrors({})\n    return true\n  }, [setFieldErrors, schema, inputRef, getAll])\n\n  const getField = useCallback(\n    <Field extends keyof Input>(name: Field) => {\n      return values[name]\n    },\n    [values]\n  )\n\n  const setField = useCallback(\n    <Field extends keyof Input>(name: keyof Input, value: Input[Field]) => {\n      setValues((values) => ({\n        ...values,\n        [name]: value\n      }))\n    },\n    [inputRef, setValues]\n  )\n\n  const validateField = useCallback(\n    <Field extends keyof Input>(name: Field) => {\n      // If there is no schema, skip validation\n      if (!schema) return true\n\n      // If it's a bound field, get the value from the ref\n      let value = values[name]\n      if (inputRef.current?.[name]?.current) {\n        value = parseValueFromInput(\n          inputRef.current[name]!.current!\n        ) as Input[Field]\n      }\n\n      const validation = schema.safeParse({\n        [name]: value\n      })\n\n      // Validate a single field\n      if (!validation.success) {\n        const errors = parseZodError<Input>(validation.error)[name]\n\n        if (errors) {\n          setFieldErrors((fieldErrors) => ({\n            ...fieldErrors,\n            [name]: errors\n          }))\n          return false\n        }\n      }\n\n      // Reset this field's error if validation is successful\n      setFieldErrors((fieldErrors) => ({\n        ...fieldErrors,\n        [name]: undefined\n      }))\n      return true\n    },\n    [setFieldErrors, schema, inputRef, getAll]\n  )\n\n  const connect = useCallback(() => {\n    return {\n      onSubmit: (event: SyntheticEvent<HTMLFormElement>) => {\n        event.preventDefault()\n\n        // Reset field errors\n        setFieldErrors({})\n\n        // If there is an onSubmit callback, call it\n        if (onSubmit && !onSubmit(getAll())) {\n          return\n        }\n\n        // Validate all fields before submitting\n        let validation = false\n        flushSync(() => {\n          validation = validateAll()\n        })\n        if (!validation) {\n          return\n        }\n\n        // Create a FormData object from the values\n        const formData = createFormData(values)\n\n        // Call the server action\n        startTransition(async () => {\n          await formAction(formData)\n        })\n      },\n      action: formAction\n    } satisfies Pick<FormHTMLAttributes<HTMLFormElement>, 'onSubmit' | 'action'>\n  }, [\n    values,\n    validateAll,\n    setFieldErrors,\n    formAction,\n    startTransition,\n    formAction\n  ])\n\n  const bindField = useCallback(\n    (name: keyof Input) => {\n      if (inputRef.current === null) {\n        inputRef.current = {}\n      }\n\n      inputRef.current[name] = createRef()\n\n      return {\n        ref: inputRef.current[name],\n        name: name.toString(),\n        onBlur: validateOnBlur ? () => validateField(name) : undefined,\n        onChange: validateOnChange ? () => validateField(name) : undefined\n      } satisfies InputHTMLAttributes<HTMLInputElement> &\n        RefAttributes<BindableField>\n    },\n    [inputRef, validateField, validateOnBlur, validateOnChange]\n  )\n\n  useEffect(() => {\n    if (formState?.error || formState?.fieldErrors) {\n      onError?.(formState?.error ?? null, formState?.fieldErrors ?? null)\n    }\n    if (formState?.response) {\n      onSuccess?.(formState.response)\n    }\n  }, [formState])\n\n  return {\n    error: formState?.error ?? null,\n    response: formState?.response ?? null,\n    fieldErrors:\n      formState?.fieldErrors ?? fieldErrors ?? ({} as FormFieldErrors<Input>),\n    isPending,\n    getAll,\n    validateAll,\n    getField,\n    setField,\n    validateField,\n    connect,\n    bindField\n  }\n}\n","import { z } from 'zod'\nimport { FormActionError } from './FormActionError'\nimport { parseZodError } from './helpers/parseZodError'\nimport { parseFormData } from './helpers/serializer'\nimport { FormAction, FormInput, FormState } from './types'\n\nexport const createFormAction = <Input extends FormInput, FormResponse>(\n  schema: z.Schema<Input>,\n  handler: (\n    validatedInput: Input,\n    initialState?: FormState<Input, FormResponse> | null\n  ) => Promise<FormResponse>\n): FormAction<Input, FormResponse> => {\n  return async (initialState, formData) => {\n    const input = parseFormData(formData)\n    const validatedInput = schema.safeParse(input)\n\n    if (!validatedInput.success) {\n      return {\n        fieldErrors: parseZodError<Input>(validatedInput.error)\n      }\n    }\n\n    try {\n      const output = await handler(validatedInput.data, initialState)\n\n      return {\n        response: output\n      }\n    } catch (error: unknown) {\n      if (error instanceof FormActionError) {\n        return { error: error.message }\n      }\n\n      throw error\n    }\n  }\n}\n\nexport { useForm } from './useForm'\n"],"names":["FormActionError","parseZodError","error","SCALARS_FIELD","createFormData","values","formData","scalars","name","value","parseFormData","input","parseValueFromInput","number","_a","_b","useForm","action","schema","initialState","initialValues","validateOnBlur","validateOnChange","onSubmit","onSuccess","onError","inputRef","useRef","isPending","startTransition","useTransition","formState","formAction","useFormState","fieldErrors","setFieldErrors","useState","setValues","getAll","useCallback","_values","field","ref","validateAll","validation","getField","setField","validateField","errors","connect","event","flushSync","bindField","createRef","useEffect","createFormAction","handler","validatedInput"],"mappings":"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"}